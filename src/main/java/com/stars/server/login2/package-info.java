/**
 * Done fixme: 账号生成的过程
 * Done fixme: 没有账号和拥有账号的过程不一样
 * Done fixme: 数据入库问题/需要缓存/缓存更新问题（封号）
 * Done fixme: 登录令牌验证: 缺时间戳的验证
 * Done fixme: 要考虑高可用（KEY POINT数据不一致影响貌似不太大）
 *
 * 潜在缺陷：
 *   1. 数据库错误处理
 *
 * version 1.2
 * 1. 增加了“SQL语句”
 * 2. 增加了“游戏服登录流程”和“游戏服登录状态，及其转换”
 *
 * version 1.1
 * 1. 增加了“数据入库方式”
 * 2. 修改了“登录服 - 登录流程/注册流程”，新增2.1（注册/登录）和2.2（账号生成）
 * 3. 修改了“登录令牌登录（token）”，新增4.3（检查时间戳）
 * 4. 修改了“登录服集群”，修改1.3和3.1（容错性）
 *
 * version 1.0
 * 1. 初版
 *
 * --------
 *
 * 注意1：因不确定是否有多个大区，不确定是否有逻辑分区，不确定逻辑分区的形式，所以使用保守方式（改动更少）
 *   1. 应假设存在多个大区
 *   2. 应假设一个大区中存在多个逻辑分区
 *   3. 应假设玩家可以选择大区，但不能选择逻辑分区
 *   4. 应假设一个登录服（集群）对应所有大区
 *   5. 应假设登录服是以集群方法实现
 *   6. 应假设逻辑分区留待业务层考虑
 *
 * 注意2：逻辑分区相关推断和预测
 *   前提1. 玩家被划分在不同的逻辑分区
 *   前提2. 在各个逻辑分区内，玩家间会产生关系（排行榜[竞争]，好友[合作+]，公会[合作/竞争]）
 *
 *   推论1. 逻辑分区只会合并，不会拆分（好友关系是网状结构）
 *   推论2. 逻辑分区作用上等同于物理分区（数据分开存储）
 *   推论3. 逻辑分区间可能产生竞争关系（排行榜，比赛），不太可能产生合作关系
 *
 * 登录服 - 登录流程/注册流程
 *   1. 玩家请求登录（第三方SDK[须验证]，第三方SDK[不须验证]，不带SDK[自身验证]）
 *   2. 登录服完成验证（根据渠道号，选择不同的验证方式）
 *     2.1 登录服按照规则生成全局唯一账号，检查是否存在该账号
 *       A. 已存在，登录服更新玩家数据（到缓存）
 *       B. 不存在，登录服新增玩家数据（到缓存）
 *     2.2 账号生成方式：渠道码（或者渠道缩写） + "_" + 渠道的用户账号
 *       A. e.g. 100_6740 或 wx_6740
 *       B. 唯一性保证：渠道码由我们指定能够保证唯一性，渠道的用户账号对于一个渠道来说也是唯一的
 *   3. 登录服返回大区列表，对应的连接服IP和端口（根据账号确定连接服），以及登录令牌（简称token，区别于第三方登录令牌token'）
 *   4. 玩家选择大区，客户端向对应的连接服发送登录令牌
 *   5. 连接服验证登陆令牌，绑定游戏服，向游戏服转发登录令牌
 *   6. 游戏服加载用户数据，初始化，下发数据
 *
 * 数据入库方式
 *   1. 账号数据不一致的影响较小，因而可以允许一部分的数据出错，从而提高可用性
 *     1.1 主键冲突（冲突的数据可以丢弃）
 *     1.2 数据不一致（登录时间/封号时间影响也不大）
 *     1.3 数据丢失（注册时间/登录时间/选区信息/封号信息影响不大）
 *     1.4 注意：账号数据中不能带有重要的属性（例如，Vip，充值信息等）
 *   2. 数据需要入库保存
 *     2.1 需要保存以下数据：账号，渠道，注册时间，登录时间，封号信息（忽略）
 *     2.2 从登录服的角度来看，入库是异步的
 *   3. 数据需要进行缓存（数据库操作耗时）
 *     3.1 数据保存在内存中
 *       A. 缓存可能丢失（影响不大；如果丢失新增数据，下次登录再重新插入；如果丢失更新数据，则部分字段不一致）
 *       B. 对于用户请求，应先从缓存查找数据；找不到就从数据库读取数据，并数据保存在缓存中
 *       C. 对于用户数据新增/修改，将数据更新到缓存即可
 *     3.2 登录服启动时从数据库加载数据（暂不从数据库加载数据）
 *       A. 需要控制一次加载的量，需要判断登录时间（SQL带条件）
 *     3.3 实时，或定时将数据保存到数据库（暂定定时）
 *       A. 实时，指缓存数据更新后，立刻将数据保存到数据库
 *       B. 定时，指缓存数据更新后，不立刻保存；而是定期将更新数据保存到数据库
 *     3.4 定时淘汰过期数据
 *       A. 数据应该带有时间戳，在淘汰数据时用来判断是否过期（如果第三方类库有，这条可以忽略）
 *       B. 考虑使用第三方类库（Guava或者Ehcache）
 *       C. 缓存数据的有效时间应该根据实际情况进行调整（暂定一周）
 *       D. 淘汰数据前，须保证已经入库
 *   4. 入库模块实现（暂定自行实现）
 *     4.1 使用数据服
 *       A. 优点：重用现有功能
 *       B. 缺点：需要支持大批量数据传输（至少须要支持加载部分），参见3.2
 *     4.2 自行实现
 *       A. 优点：快速实现
 *       B. 缺点：数据库的配置和管理；须维护多一套代码
 *
 *
 * 统一验证过程和步骤 --> fixme: 暂时不需要考虑，会有银汉SDK；先预留接口
 *   A. 第三方SDK[须验证]
 *     A1) 玩家请求登录（一般登录请求带有第三方的登录令牌，简称token'）
 *     A2) 登录服请求第三方验证token'
 *     A3) 第三方返回验证结果（成功/失败/超时）
 *     A4) 登录服完成验证
 *   B. 第三方SDK[不须验证]
 *     B1) 玩家请求登录（一般登录请求带有第三方的登录令牌，简称token'）
 *     B2) 登录服完成验证
 *   C. 不带SDK[自身验证]
 *     C1) 玩家请求登录（一般登录请求带有玩家账号和密码）
 *     C2) 登录服判断账号是否有效（合法/属于这个登录服管理）
 *     C3) 查库验证密码是否正确（成功/失败/超时）
 *     C4) 登录服完成验证
 *
 * 登录令牌登录（token）
 *   1. 登录令牌组成：账号，时间戳，其他信息（渠道号/特权/VIP），数字签名A
 *   2. 使用数字签名（MD5）确保其安全性
 *   3. 数字签名生成形式：账号 + 时间戳 + 其他信息 + 填充文本（服务私有） --MD5-->  数字签名
 *   4. 登录令牌验证过程：
 *     4.1 服务端根据登录令牌中的账号、渠道号、时间戳、其他信息和服务端私有的填充文本做MD5，生成数字签名B
 *     4.2 服务端比较登录令牌中的数字签名A和生成的数字签名B，不相等则验证失败（登录令牌已被修改）
 *     4.3 服务端检查时间戳是否过期，没过期则验证通过，过期则验证失败
 *
 * 登录服集群
 *   1. 实现思路
 *     1.1 对用户进行划分，每个服务进程只处理一部分用户
 *     1.2 划分方式：对用户账号做哈希运算，哈希值取模进行划分
 *     1.3 登录服对于非自身处理的账号，按以下方式进行处理
 *       A. 按正常方式处理
 *       B. 返回一个错误码，提示客户端需要更新关系表（todo: 还未实现）
 *   2. 客户端如何访问
 *     2.1 客户端应该持有一份哈希值和登录服的关系表
 *     2.2 客户端在访问登录服前，应该先根据用户输入的账号做哈希运算，根据哈希值取模后（登录服大小）找到对应的登录服，再进行访问
 *     2.3 客户端应该及时更新哈希值和登录服的关系表
 *     2.4 如果客户端访问了错误的登录服，那么登录服将响应一个错误码，收到此错误码后，客户端需要更新关系表
 *     2.5 如果客户端发现对应的登录服不能访问（应有一个较长的时间间隔），则按以下方式进行（暂定A）
 *       A. 随机找一个登录服进行登录
 *       B. （思考） 是否可以再取模（登录服大小 - 1），模相等则找模+1的登录服，否则找模的登录服；如果登录服还不能访问，则继续该步骤
 *
 *   3. 容错性
 *     3.1 在某个登录服宕机时，客户端可以自动切换到别的登录服进行登录
 *       A. 会导致数据不一致（影响较少），所以登录服不要保存重要数据
 *
 * 数据存放
 *   1. 数据须根据一定规则分块存放（sharding）
 *      1.1 必须考虑用户总量，每个分块存储的最大值？
 *      1.2 每个服务进程对应多个数据分块，一个数据分块对应一个服务进程
 *      1.3 用户数量根据用户账号的哈希值分配到对应的数据分块
 *   2. 数据超过设定容量，须要对数据重新分块（resharding）
 *      2.1 对每个数据分块根据规则进行再分成小块（存储过程/外部程序）
 *      2.2 把小块汇总成新的数据分块
 *
 * --------
 * Sql语句
 * -- 用户账号表
 * CREATE TABLE `account` (
 *   `unique_id` varchar(128) NOT NULL,
 *   `channel_id` int(11) NOT NULL,
 *   `account` varchar(128) NOT NULL,
 *   `reg_timestamp` datetime NOT NULL,
 *   `login_timestamp` datetime NOT NULL,
 *   PRIMARY KEY (`unique_id`)
 * ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
 *
 * -- 大区信息
 * CREATE TABLE `game_zone` (
 *   `id` INT NOT NULL,
 *   `name` VARCHAR(128) NOT NULL,
 *   PRIMARY KEY (`id`)
 * ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
 *
 * -- 服务器信息
 * CREATE TABLE `game_zone_server` (
 *   `id` INT NOT NULL,
 *   `zone_id` INT NOT NULL,
 *   `ip` VARCHAR(128) NOT NULL,
 *   `port` INT NOT NULL,
 *   PRIMARY KEY(`id`)
 * ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
 *
 * --------
 * 游戏服登录流程
 *   1. 游戏服收到用户登录请求
 *   2. 游戏服验证登陆令牌，并检查是否超时（失败 -> 返回提示）
 *   3. 重复、并发登录检查
 *     3.1 游戏服加上分布式锁（所有失败情况 -> 返回提示，并解除分布式锁）
 *     3.2 会话检查
 *     3.3 设置流水号、会话和状态
 *     3.4 绑定账号和游戏服的关系
 *   4. 判断内存中是否有用户数据
 *     4.1 存在用户数据，继续步骤7
 *     4.2 新用户数据，创建用户数据
 *     4.2 不存在用户数据，请求加载用户数据
 *   5. 创建用户数据
 *     5.1 调用各模块的创建函数(Module.onCreation())创建用户数据
 *     5.2 请求数据服保存用户数据
 *     5.3 数据服完成保存，继续步骤7
 *   6. 加载用户数据
 *     6.1 游戏服调用各模块的数据请求函数（Module.onDataReq()），添加请求
 *     6.2 游戏服请求数据服加载用户数据
 *     6.3 数据服完成加载
 *     6.4 游戏服调用各模块的数据响应函数（Module.onDataResp()），获取数据
 *     6.5 继续步骤7
 *   7. 初始化/下发数据
 *     7.1 检查每日重置（每周/每月）
 *     7.2 调用各模块初始化函数
 *     7.3 调用各模块下发数据函数
 *     7.4 解除分布式锁
 *     7.5 下发登录成功的数据包
 *
 * 状态及相关转换/流水号/会话
 *   1. 登录模块使用状态、流水号和会话来处理重复登录、并发登录和登录下线交叉进行的问题
 *   2. 每个登录步骤失败时，必须修改相关状态（以免出现卡住的情况）
 *
 * 状态枚举
 *   INITIAL - 初始态
 *   DOING - 处理中
 *   DONE - 已完成
 *   OFFLINE_BEGIN - 离线处理中
 *   OFFLINE_SAVED - 离线已保存
 *   KICKOFF_BEGIN - 踢下线处理中
 *
 * 状态转换
 *   INTIAL --收到登录请求--> DOING
 *
 *   DOING --收到登录请求--> DOING
 *   DOING --完成登录--> DONE
 *   DOING --登录过程出错--> END
 *   DOING --登录过程离线--> END
 *   DOING --登录过程强制下线--> END
 *
 *   DONE --收到登录请求--> DOING
 *   DONE --离线--> OFFLINE_BEGIN
 *   DONE --强制下线--> KICKOFF_BEGIN
 *
 *   OFFLINE_BEGIN --收到登录请求--> DOING
 *   OFFLINE_BEGIN --收到自动保存响应--> END
 *
 *   KICKOFF_BEGIN --收到自动保存响应--> END
 *
 *
 * Created by zhaowenshuo on 2016/2/16.
 */
package com.stars.server.login2;