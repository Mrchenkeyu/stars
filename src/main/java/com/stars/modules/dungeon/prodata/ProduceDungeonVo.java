package com.stars.modules.dungeon.prodata;import com.stars.modules.dungeon.DungeonManager;import com.stars.network.server.buffer.NewByteBuffer;import com.stars.util.StringUtil;import java.util.HashMap;import java.util.Map;/** * Created by liuyuheng on 2016/9/1. */public class ProduceDungeonVo {    private int produceDungeonId;// '经验副本id'    private byte type;// '副本类型(1=经验副本;2=银币副本)'    private String name;// '名称'    private int stageId;// '调用场景Id'    private String levelRange;// '等级段限制'    private String doubleCost;// '翻倍消耗道具'    private String doubleItem;// '翻倍道具倍率'    private String expSwitchItem;// '满级之后经验转换道具和系数'    private int dropId;//通关奖励    private int dailyId;//对应的日常活动    // 内存数据    private int[] levelRangeArray;// 等级段 [min,max]    private Map<Integer, Integer> doubleCostMap = new HashMap<>();// 翻倍消耗道具 <itemId,number>    private Map<Integer, Double> doubleItemRate = new HashMap<>();// 倍率 <itemId,rate>    private Map<Integer, Double> expSwitchMap = new HashMap<>();// 经验转换道具 <itemid,转换系数>    public void writeToBuff(NewByteBuffer buff) {        buff.writeInt(produceDungeonId);        buff.writeByte(type);        buff.writeString(name);        buff.writeString(doubleCost);        buff.writeString(doubleItem);        buff.writeString(expSwitchItem);    }    public int getDailyId() {        return dailyId;    }    /**     * 防止策划配置错误： 如果检测到一个type对应了多个dailyid, 直接以producedungeonid最小的那行数据对应的dailyid为准     *     * @param type 资源副本类型     * @return 返回producedungeonid最小的那行数据对应的dailyid。     */    public int getDailyId(byte type) {        int minProduceDungeonId = 0;        for (Map.Entry<Integer, ProduceDungeonVo> entry : DungeonManager.produceDungeonVoMap.get(type).entrySet()) {            ProduceDungeonVo vo = entry.getValue();            if (minProduceDungeonId == 0) {                minProduceDungeonId = vo.getProduceDungeonId();            }            minProduceDungeonId = minProduceDungeonId > vo.getProduceDungeonId() ? vo.getProduceDungeonId() : minProduceDungeonId;        }        return DungeonManager.produceDungeonVoMap.get(type).get(minProduceDungeonId).getDailyId();    }    public void setDailyId(int dailyId) {        this.dailyId = dailyId;    }    public int getDropId() {        return dropId;    }    public void setDropId(int dropId) {        this.dropId = dropId;    }    public int[] getLevelRangeArray() {        return levelRangeArray;    }    public int getProduceDungeonId() {        return produceDungeonId;    }    public void setProduceDungeonId(int produceDungeonId) {        this.produceDungeonId = produceDungeonId;    }    public byte getType() {        return type;    }    public void setType(byte type) {        this.type = type;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getStageId() {        return stageId;    }    public void setStageId(int stageId) {        this.stageId = stageId;    }    public String getLevelRange() {        return levelRange;    }    public void setLevelRange(String levelRange) throws Exception {        this.levelRange = levelRange;        if (StringUtil.isEmpty(levelRange) || "0".equals(levelRange)) {            throw new IllegalArgumentException("expdungeon表levelrange字段配置错误");        }//        levelRangeArray = StringUtil.parseIntList(levelRange, "\\+");        levelRangeArray = StringUtil.toArray(levelRange, int[].class, '+');    }    public Map<Integer, Integer> getDoubleCostMap() {        return doubleCostMap;    }    public void setDoubleCostMap(Map<Integer, Integer> doubleCostMap) {        this.doubleCostMap = doubleCostMap;    }    public Map<Integer, Double> getDoubleItemRate() {        return doubleItemRate;    }    public void setDoubleItemRate(Map<Integer, Double> doubleItemRate) {        this.doubleItemRate = doubleItemRate;    }    public Map<Integer, Double> getExpSwitchMap() {        return expSwitchMap;    }    public void setExpSwitchMap(Map<Integer, Double> expSwitchMap) {        this.expSwitchMap = expSwitchMap;    }    public String getDoubleCost() {        return doubleCost;    }    public void setDoubleCost(String doubleCost) throws Exception {        this.doubleCost = doubleCost;        if (StringUtil.isEmpty(doubleCost) || "0".equals(doubleCost)) {            return;        }        doubleCost = doubleCost.replace("+", "=");//        this.doubleCostMap = StringUtil.parseIntegerMap(doubleCost, "\\|", HashMap.class);        this.doubleCostMap = StringUtil.toMap(doubleCost, Integer.class, Integer.class, '=', '|');    }    public String getDoubleItem() {        return doubleItem;    }    public void setDoubleItem(String doubleItem) {        this.doubleItem = doubleItem;        if (StringUtil.isEmpty(doubleItem) || "0".equals(doubleItem)) {            return;        }        this.doubleItemRate = parse(doubleItem);    }    public String getExpSwitchItem() {        return expSwitchItem;    }    public void setExpSwitchItem(String expSwitchItem) {        this.expSwitchItem = expSwitchItem;        if (StringUtil.isEmpty(expSwitchItem) || "0".equals(expSwitchItem)) {            return;        }        this.expSwitchMap = parse(expSwitchItem);    }    private Map<Integer, Double> parse(String param) {        Map<Integer, Double> map = new HashMap<>();        for (String arg : param.split("\\|")) {            String[] temp = arg.split("\\+");            map.put(Integer.parseInt(temp[0]), Integer.parseInt(temp[1]) / 100.0);        }        return map;    }}